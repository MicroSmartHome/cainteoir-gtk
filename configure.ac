AC_PREREQ([2.65])
AC_INIT([Cainteoir Text-to-Speech], [0.5], [msclrhd@gmail.com], [cainteoir-gtk], [https://github.com/rhdunn/cainteoir-gtk])
AM_INIT_AUTOMAKE()

m4_ifdef([AM_SILENT_RULES],[AM_SILENT_RULES])
AM_SILENT_RULES([yes])

AC_CONFIG_SRCDIR([src])
AC_CONFIG_MACRO_DIR([m4])
AC_CONFIG_HEADERS([config.h])

AM_GNU_GETTEXT([external])
AM_GNU_GETTEXT_VERSION(0.17)

LT_INIT

dnl ================================================================
dnl Program checks.
dnl ================================================================

AC_PROG_CXX
AC_PROG_MAKE_SET

dnl ================================================================
dnl C++11 support
dnl ================================================================

AC_LANG_PUSH(C++)
AC_MSG_CHECKING([if $CXX supports C++11 without any flags])
AC_COMPILE_IFELSE(
	[AC_LANG_PROGRAM(
		[[template <typename T> struct right_angle_brackets {};]
		 [typedef right_angle_brackets<right_angle_brackets<int>> cpp11_check;]],
		[[]])],
	[AC_MSG_RESULT([yes])
	 have_cxx11_native=yes],
	[AC_MSG_RESULT([no])
	 have_cxx11_native=no])
AC_LANG_POP(C++)

AC_LANG_PUSH(C++)
TEMP_CXXFLAGS="$CXXFLAGS"
CXXFLAGS="$CXXFLAGS -std=c++11"
AC_MSG_CHECKING([if $CXX supports C++11 with the -std=c++11 flag])
AC_COMPILE_IFELSE(
	[AC_LANG_PROGRAM(
		[[template <typename T> struct right_angle_brackets {};]
		 [typedef right_angle_brackets<right_angle_brackets<int>> cpp11_check;]],
		[[]])],
	[AC_MSG_RESULT([yes])
	 have_cxx11_cxx11=yes],
	[AC_MSG_RESULT([no])
	 have_cxx11_cxx11=no])
CXXFLAGS="$TEMP_CXXFLAGS"
AC_LANG_POP(C++)

AC_LANG_PUSH(C++)
TEMP_CXXFLAGS="$CXXFLAGS"
CXXFLAGS="$CXXFLAGS -std=gnu++11"
AC_MSG_CHECKING([if $CXX supports C++11 with the -std=gnu++11 flag])
AC_COMPILE_IFELSE(
	[AC_LANG_PROGRAM(
		[[template <typename T> struct right_angle_brackets {};]
		 [typedef right_angle_brackets<right_angle_brackets<int>> cpp11_check;]],
		[[]])],
	[AC_MSG_RESULT([yes])
	 have_cxx11_gnuxx11=yes],
	[AC_MSG_RESULT([no])
	 have_cxx11_gnuxx11=no])
CXXFLAGS="$TEMP_CXXFLAGS"
AC_LANG_POP(C++)

AC_LANG_PUSH(C++)
TEMP_CXXFLAGS="$CXXFLAGS"
CXXFLAGS="$CXXFLAGS -std=c++0x"
AC_MSG_CHECKING([if $CXX supports C++11 with the -std=c++0x flag])
AC_COMPILE_IFELSE(
	[AC_LANG_PROGRAM(
		[[template <typename T> struct right_angle_brackets {};]
		 [typedef right_angle_brackets<right_angle_brackets<int>> cpp11_check;]],
		[[]])],
	[AC_MSG_RESULT([yes])
	 have_cxx11_cxx0x=yes],
	[AC_MSG_RESULT([no])
	 have_cxx11_cxx0x=no])
CXXFLAGS="$TEMP_CXXFLAGS"
AC_LANG_POP(C++)

AC_LANG_PUSH(C++)
TEMP_CXXFLAGS="$CXXFLAGS"
CXXFLAGS="$CXXFLAGS -std=gnu++0x"
AC_MSG_CHECKING([if $CXX supports C++11 with the -std=gnu++0x flag])
AC_COMPILE_IFELSE(
	[AC_LANG_PROGRAM(
		[[template <typename T> struct right_angle_brackets {};]
		 [typedef right_angle_brackets<right_angle_brackets<int>> cpp11_check;]],
		[[]])],
	[AC_MSG_RESULT([yes])
	 have_cxx11_gnuxx0x=yes],
	[AC_MSG_RESULT([no])
	 have_cxx11_gnuxx0x=no])
CXXFLAGS="$TEMP_CXXFLAGS"
AC_LANG_POP(C++)

AC_MSG_CHECKING([if $CXX supports C++11])
if test "$have_cxx11_cxx11" = yes ; then
	AC_MSG_RESULT([-std=c++11])
	CXXFLAGS="$CXXFLAGS -std=c++11"
elif test "$have_cxx11_gnuxx11" = yes ; then
	AC_MSG_RESULT([-std=gnu++11])
	CXXFLAGS="$CXXFLAGS -std=gnu++11"
elif test "$have_cxx11_cxx0x" = yes ; then
	AC_MSG_RESULT([-std=c++0x])
	CXXFLAGS="$CXXFLAGS -std=c++0x"
elif test "$have_cxx11_gnuxx0x" = yes ; then
	AC_MSG_RESULT([-std=gnu++0x])
	CXXFLAGS="$CXXFLAGS -std=gnu++0x"
elif test "$have_cxx11_native" = yes ; then
	AC_MSG_RESULT([yes])
else
	AC_MSG_RESULT([no])
	AC_MSG_ERROR([C++11 is not supported by $CXX.])
fi

dnl ================================================================
dnl C++11 language support
dnl ================================================================

AC_LANG_PUSH(C++)
AC_MSG_CHECKING([if $CXX supports C++11 nullptr])
AC_COMPILE_IFELSE(
	[AC_LANG_PROGRAM(
		[[]],
		[[const char *ptr = nullptr;]])],
	[AC_MSG_RESULT([yes])
	 AC_DEFINE([HAVE_CPP_NULLPTR],[1],[Define 1 if the nullptr keyword is not supported.])],
	[AC_MSG_RESULT([no])
	 dnl Check if a workaround for a gcc bug is needed
	 AC_MSG_CHECKING([if $CXX supports implicit conversions for ==/!=])
	 AC_COMPILE_IFELSE(
		[AC_LANG_PROGRAM(
			[[const struct nullptr_t]
			 [{]
			 [	template<class T> inline operator T*() const { return 0; }]
			 [} nullptr = {};]],
			[[const char *ptr = "testing";]
			 [return (ptr != nullptr) ? 0 : 1]])],
		[AC_MSG_RESULT([yes])
		 AC_DEFINE([HAVE_CPP_IMPLICIT_NULLPTR_COMPARE],[1],[Define 1 if the nullptr workaround needs ==/!= definitions.])],
		[AC_MSG_RESULT([no])])])
AC_LANG_POP(C++)

AC_LANG_PUSH(C++)
AC_MSG_CHECKING([if $CXX supports C++11 decltype])
AC_COMPILE_IFELSE(
	[AC_LANG_PROGRAM(
		[[]],
		[[int a;]
		 [decltype(a) b = a;]])],
	[AC_MSG_RESULT([yes])],
	[AC_MSG_RESULT([no])
	 AC_MSG_ERROR([C++11 decltype not supported by $CXX.])])
AC_LANG_POP(C++)

AC_LANG_PUSH(C++)
AC_MSG_CHECKING([if $CXX supports C++11 auto])
AC_COMPILE_IFELSE(
	[AC_LANG_PROGRAM(
		[[]],
		[[class A {} a;]
		 [auto b = a;]])],
	[AC_MSG_RESULT([yes])],
	[AC_MSG_RESULT([no])
	 AC_MSG_ERROR([C++11 decltype not supported by $CXX.])])
AC_LANG_POP(C++)

AC_LANG_PUSH(C++)
AC_MSG_CHECKING([if $CXX supports C++11 brace initialization])
AC_COMPILE_IFELSE(
	[AC_LANG_PROGRAM(
		[[#include <complex>]],
		[[std::complex<float> c { 0.1, 0.2 };]])],
	[AC_MSG_RESULT([yes])],
	[AC_MSG_RESULT([no])
	 AC_MSG_ERROR([C++11 brace initialization not supported by $CXX.])])
AC_LANG_POP(C++)

dnl ================================================================
dnl C++11 library support
dnl ================================================================

AC_LANG_PUSH(C++)
AC_MSG_CHECKING([if $CXX supports C++11 std::initializer_list])
AC_COMPILE_IFELSE(
	[AC_LANG_PROGRAM(
		[[#include <vector>]
		 [std::initializer_list<int> il = { 1, 2, 3, 4 };]],
		[[std::vector<int> v(il);]])],
	[AC_MSG_RESULT([yes])],
	[AC_MSG_RESULT([no])
	 AC_MSG_ERROR([C++11 std::initializer_list not supported by $CXX.])])
AC_LANG_POP(C++)

AC_LANG_PUSH(C++)
AC_MSG_CHECKING([if $CXX supports C++11 std::shared_ptr])
AC_COMPILE_IFELSE(
	[AC_LANG_PROGRAM(
		[[#include <memory>]],
		[[std::shared_ptr<int> p = std::make_shared<int>(5);]])],
	[AC_MSG_RESULT([yes])],
	[AC_MSG_RESULT([no])
	 AC_MSG_ERROR([C++11 std::shared_ptr not supported by $CXX.])])
AC_LANG_POP(C++)

dnl ================================================================
dnl getopt checks.
dnl ================================================================

AC_CHECK_HEADERS([getopt.h])
AC_CHECK_FUNCS([getopt_long])

dnl ================================================================
dnl GTK+ checks.
dnl ================================================================

PKG_CHECK_MODULES([GTK], [gtk+-3.0 >= 3.0.0])
AC_SUBST(GTK_CFLAGS)
AC_SUBST(GTK_LIBS)

AC_MSG_CHECKING([if GTK+ CSS themes need an explicit px unit specifier])
PKG_CHECK_EXISTS([gtk+-3.0 >= 3.4.0],
	[AC_MSG_RESULT([yes])
	 AC_SUBST(GTK_PX, [px])],
	[AC_MSG_RESULT([no])
	 AC_SUBST(GTK_PX, [])])

dnl ================================================================
dnl sigc++ checks.
dnl ================================================================

PKG_CHECK_MODULES([SIGCXX], [sigc++-2.0])
AC_SUBST(SIGCXX_CFLAGS)
AC_SUBST(SIGCXX_LIBS)

dnl ================================================================
dnl Generate output.
dnl ================================================================

AC_CONFIG_FILES([
	Makefile
	po/Makefile.in
	data/themes/gtk3-common.css
	data/themes/Adwaita/gtk3.css
	data/themes/Ambiance/gtk3.css
	data/themes/Radiance/gtk3.css
])
AC_OUTPUT

AC_MSG_NOTICE([

    Configuration for Cainteoir Text-to-Speech Gtk front-end complete.

        Source code location:          ${srcdir}
        Compiler:                      ${CXX}
        Compiler flags:                ${CXXFLAGS}
])
